# 一、shell

> 1、shell 的概念：shell 就是一个命令解释器，解释型语言，当你在 linux 界面发出一个指令时，命令先传到 shell，然后在将这个指令翻译成计算机可以识别的二进制语言，然后传给计算机内核，告诉他要做什么事情。计算机内核将结果返还给 shell，shell 翻译成人所熟悉的语言，将结果展示出来
>
> 2、内部命令：就是 shell 程序的一部分，在系统启动时就加载进入内存，是常驻内存的，所以执行效率高，内部命令在目录列表是看不见的，他们有 shell 本身提供，常用的内部命令有 cd，pwd,echo,eval,exec,export,readonly,read ,shift,wait
>
> 3、外部命令：也就是文件系统命令，它不是 shell 程序组成部分，是 shell 程序之外的程序，是系统软件的功能，用户需要时才从硬盘中读入内存，所以相对来说速度就慢一点，通常放在/bin，/usr/bin，/sbin，/usr/sbin。
>
> 4、区分内部命令和外部命令： 使用 type 或者 enable 进行查看，如 type cd type 的-a 参数
>
> 5、shell 的种类：cat /etc/shells

```sh
/bin/sh				  # 是bash的一个快捷方式
/bin/bash			  # bash是大多数Linux默认的shell，包含的功能几乎可以涵盖shell所有的功能
/sbin/nologin		# 表示非交互，不能登录操作系统
/bin/dash			  # 小巧，高效，功能相比少一些
/bin/csh			  # 具有C语言风格的一种shell，具有许多特性，但也有一些缺陷
/bin/tcsh			  # 是csh的增强版，完全兼容csh
```

## 1. shell 脚本能干啥？

① 自动化软件部署 LAMP/LNMP/Tomcat...

② 自动化管理 系统初始化脚本、批量更改主机密码、推送公钥...

③ 自动化分析处理 统计网站访问量

④ 自动化备份 数据库备份、日志转储...

⑤ 自动化监控脚本

## 2. shell 脚本执行操作

```sh
# 标准执行
./001.sh
/opt/shell/001.sh
# 非标准执行
sh 001.sh
bash 001.sh
bash -x 001.sh    # -x 一般用于排错，查看脚本的执行过程
bash -n 001.sh    # -n 用来查看脚本的语法是否有问题
#使用source命令读取脚本文件,执行文件里的代码
source 001.sh
```

## 2. 变量的定义

```shell
# 1、 变量名=变量值
# 2、 定义规则：区分大小写，一般变量名使用大写，不能有特殊符号，不能数字开头，等号两边不能有空格，如果变量中间有空格，需要用引号引起来
# 3、 取消变量：unset A
# 4、 定义分类
		- 直接赋值：  A='hello world'      $A和${A}的区别：${变量名}可以只截取变量的一部分${A:索引:长度}，而$变量名不可以
		- 命令执行结果赋值给变量：  B=$(uname -r)   B=`date +%F`  2021-02-24  C= `date +'%F %T'`
		- 交互式定义变量:   read -p "please input param:" -t 30  name       # -p 提示信息  -t 超时时间（s） -s 不显示输入内容   -n 定义字符数，限制输入长度
    - 配置文件输入：    read ip mask < xx.txt
		- 定义有类型的变量（declare）：  declare 选项 变量名=变量值   		# -i 整数、-r 只读、-x 通过环境导出、 -a 定义普通数组  declare -x AAA=123456 等于 export AAA=123456
    - dirname：   A=/opt/shell/text.sh  dirname $A  =>  /opt/shell
    - basename：  basename $A   =>  text.sh
    - 获取变量长度：  A=hello   echo ${#A}    => 5
    - 替换：  echo ${url/ao/AO} 用AO代替ao（从左往右第一个）  echo ${url//ao/AO}  贪婪替换（替代所有）
# 5、 变量分类
	本地变量 -->  当前进程中有效，其他进程及当前进程的子进程无效。
	环境变量 -->
	全局变量 -->  全局所有的用户和程序都能调用，/etc/profile、/etc/bashrc
  系统变量 -->  系统变量(内置bash中变量)， shell本身已经固定好了它的名字和作用.如下表


# 增强脚本错误处理能力  
set -e                        # 立即退出模式。当任何一条命令的返回值（exit code）非零（即失败）时，立即终止脚本执行。
set -o pipefail               # 管道失败模式。默认情况下，Shell 仅以管道中最后一个命令的返回值作为整个管道的状态。启用后，管道中任意命令失败（非零退出码）都会使整个管道视为失败。

```

| 内置变量   | 含义                                                                                                                    |
| ---------- | ----------------------------------------------------------------------------------------------------------------------- |
| $?         | 上一条命令执行后返回的状态；状态值为 0 表示执行正常，非 0 表示执行异常或错误                                            |
| $0         | 当前执行的程序或脚本名 (./02.sh)                                                                                        |
| $#         | 脚本后面接的参数的个数 3 个                                                                                             |
| $\*        | 脚本后面所有参数，参数当成一个整体输出，每一个变量参数之间以空格隔开 (参数数组 a b c)                                   |
| $@         | 脚本后面所有参数，参数是独立的，也是全部输出 (参数数组 a b c)                                                           |
| $1~$9      | 脚本后面的位置参数，$1 表示第 1 个位置参数，依次类推                                                                    |
| ${10}~${n} | 扩展位置参数,第 10 个位置变量必须用{}大括号括起来(2 位数字以上扩起来)                                                   |
| $$         | 当前所在进程的进程号，如`echo $$`                                                                                       |
| $！        | 后台运行的最后一个进程号 测试: sleep 400 &(后台运行)/sleep 400(ctrl+z 暂停运行), 再运行 jobs, 查看当前进程的后台子进程. |
| !$         | 调用最后一条命令历史中的参数                                                                                            |

## 3. 四则运算

| 表达式 | 举例                          |
| ------ | ----------------------------- |
| $(( )) | echo $((1+1))                 |
| $[ ]   | echo $[10-5]                  |
| expr   | expr 10 / 5                   |
| let    | n=1;let n+=1 等价于 let n=n+1 |

## 4. 条件判断

### 4.1 判断文件类型

`软链接，如果源文件不存在，软连接文件使用-f判断时为false、如果源文件存在，使用-f判断为ture`

| 判断参数 | 含义                                                   | 说明         |
| -------- | ------------------------------------------------------ | ------------ |
| -e       | 判断文件是否存在（link 文件指向的也必须存在）,链接     | exists       |
| -f       | 判断文件是否存在并且是一个普通文件，也可能是链接文件。 | file         |
| -d       | 判断文件是否存在并且是一个目录                         | directory    |
| -L       | 判断文件是否存在并且是一个软连接文件                   | soft link    |
| -b       | 判断文件是否存在并且是一个块设备文件                   | block        |
| -S       | 判断文件是否存在并且是一个套接字文件                   | socket       |
| -c       | 判断文件是否存在并且是一个字符设备文件                 | char         |
| -p       | 判断文件是否存在并且是一个命名管道文件                 | pipe         |
| -s       | 判断文件是否存在并且是一个非空文件（有内容）           | is not empty |

### 4.2 判断文件权限

| 判断参数 | 含义                                               |
| -------- | -------------------------------------------------- |
| -r       | 当前用户对其是否可读                               |
| -w       | 当前用户对其是否可写                               |
| -x       | 当前用户对其是否可执行                             |
| -u       | 是否有 suid，高级权限冒险位                        |
| -g       | 是否 sgid，高级权限强制位                          |
| -k       | 是否有 t 位，高级权限粘滞位 (创建者/root 才能删除) |

### 4.3 判断文件新旧

`新旧指的是文件的修改时间。`

| 判断参数        | 含义                                                           |
| --------------- | -------------------------------------------------------------- |
| file1 -nt file2 | 比较 file1 是否比 file2 新                                     |
| file1 -ot file2 | 比较 file1 是否比 file2 旧                                     |
| file1 -ef file2 | 比较是否为同一个文件，或者用于判断硬连接，是否指向同一个 inode |

### 4.4 判断整数

| 判断参数  | 含义     |
| --------- | -------- |
| -eq ==    | 相等     |
| -ne <> != | 不等     |
| -gt       | 大于     |
| -lt       | 小于     |
| -ge       | 大于等于 |
| -le       | 小于等于 |

### 4.5 判断字符串

| 判断参数           | 含义                                          |
| ------------------ | --------------------------------------------- |
| -z                 | 判断是否为空字符串，字符串长度为 0 则成立     |
| -n                 | 判断是否为非空字符串，字符串长度不为 0 则成立 |
| string1 = string2  | 判断字符串是否相等                            |
| string1 != string2 | 判断字符串是否相不等                          |

::

### 4.6 多重条件判断

`;表示都会执行`

| 判断符号   | 含义   | 举例                                              |
| ---------- | ------ | ------------------------------------------------- |
| -a 和 &&   | 逻辑与 | [ 1 -eq 1 -a 1 -ne 0 ] [ 1 -eq 1 ] && [ 1 -ne 0 ] |
| -o 和 \|\| | 逻辑或 | [ 1 -eq 1 -o 1 -ne 1 ]                            |

## 5. 语句(if/for/while)

### 5.1 if:vertical_traffic_light:

```shell
1. test exp1 # 原理
2. [ exp1 ]
3. [[ exp1 ]]

# [ ] 和 [[ ]] 有什么区别？
单个 [  ] 使用字符串对字符串必须加双引号
两个 [[  ]] 不用对字符串变量加双引号
两个 [[  ]] 里面可以使用 &&,||, 而单个不行，单个[] 可以使用-a

if [ condition ];then
  echo ...
elif [ condition ];then
  echo ...
else
  echo ...
fi

if [ condition ]   # 必须有间隔
  then
   echo ...
fi

&> /dev/null   将提示信息输入到/dev/null
```

### 5.2 for:v:

```shell
# 求和：使用 let sum=$sum+$i /  sum=$[$sum+$i]
# 循坏：`seq 1 2 100`  / {1..100..2}  ((i=1;i<100;i+=2))
# continue：继续；表示循环体内下面的代码不执行，重新开始下一次循环
# break：打断；马上停止执行本次循环，执行循环体后面的代码
# exit：表示直接跳出程序
for i in 1 2 3
do
	echo $i
done

for i in $(ls -l)
do
	echo $i
done

for((i=1;i<=5;i++))   # 可以没有间隔
	do
		echo $i
	done
```

### 5.3 while:v:

```shell
while [ 表达式 ]   # 中括号有间隔
do
    command...
done
```

### 5.4 until

```shell
`条件为假就进入循环；条件为真就退出循环
until expression   [ 1 -eq 1 ]  (( 1 >= 1 ))   # until ((  expression  ))
	do
		command
		command
		...
	done
```

### 5.5 case

```shell
说明：pattern表示需要匹配的模式


case var in             定义变量;var代表是变量名
pattern 1)              模式1;用 | 分割多个模式，相当于or
    command1            需要执行的语句
    ;;                  两个分号代表命令结束
pattern 2)
    command2
    ;;
pattern 3)
    command3
    ;;
		  *)              default，不满足以上模式，默认执行*)下面的语句
    command4
    ;;
esac							esac表示case语句结束

```

## 6. 函数

- ① 格式

```shell
函数名()
{
  函数体（一堆命令的集合，来实现某个功能）
}
function 函数名()
{
   函数体（一堆命令的集合，来实现某个功能）
   echo hello
   echo world
}
# 函数中return说明:
1. return可以结束一个函数。类似于循环控制语句break(结束当前循环，执行循环体后面的代码)。
2. return默认返回函数中最后一个命令状态值，也可以给定参数值，范围是0-256之间。
3. 如果没有return命令，函数将返回最后一个指令的退出状态值。
```

- ② 调用
  - 当前命令行调用，`需要重启执行source xx.sh sh xxx.sh`
  - 定义到用户的环境变量中/home/xxx/.bashrc，`当用户打开bash的时候会读取该文件`
  - 脚本中调用`调用时可以传参数，比如：method param，在函数中使用$1来接收`

## 7. 通配符与正则

```shell
*		# 匹配0个或者多个任意字符
？	   # 匹配单个字符
[list]  # 匹配list种的任意单个字符或者一组字符
{string1,string2,...}		# 匹配string1,string2或更多字符串 {1..100}, 匹配1~100
```

## 8. 引号

- 双引号：引号的内容当成整体来看待，允许通过$符号引用其他变量值，可以使用变量 echo "$(hostname)"
- 单引号：引号的内容当成整体来看待，禁止引用其他变量值(不可以使用变量)，shell 中特殊符号都被视为普通字符
- 反撇号：反撇号和$()一样，引号或括号里的命令会优先执行，如果存在嵌套，反撇号不能用

## 9. 数组

- 普通数组：只能使用整数作为数组索引(元素的下标)
- 关联数组：可以使用字符串作为数组索引(元素的下标)

```shell
# 数组定义
	数组名[索引下标]=值
	数组名=(值1 值2 值3 ...)

array[0]=v1
array[1]=v2
array[2]=v3

array=(var1 var2 var3 var4)

array1=(`cat /etc/passwd`)			将文件中每一行赋值给array1数组
array2=(`ls /root`)
array3=(harry amy jack "Miss Hou")
array4=(1 2 3 4 "hello world" [10]=linux)

${数组名[元素下标]}

echo ${array[0]}			获取数组里第一个元素
echo ${array[*]}			获取数组里的所有元素
echo ${#array[*]}			获取数组里所有元素个数
echo ${!array[@]}    	获取数组元素的索引下标
echo ${array[@]:1:2}    访问指定的元素；1代表从下标为1的元素开始获取；2代表获取后面几个元素
```

## 10. 随机数

`echo $RANDOM RANDOM，默认会产生0~32767的随机整数`

```shell
$RANDOM
echo $[$RANDOM%900+100]  # 产生三位数的随机数
echo $[$RANDOM%2]		 # 产生0-1的随机数
```

## 11. 其他命令

1. time: 打印出一条命令或者一个程序的执行时间；以秒为单位将一条命令执行期间所用的时间、系统时间和 time 命令的执行时间打印在标准错误中

- real：表示从程序开始到程序执行结束时所消耗的时间，包括 cpu 的用时。CPU 用时被划分为 user 和 sys 两块
- user：表示程序本身，以及它所调用的库中的子例程使用的时间
- sys： 由程序直接或间接调用的系统调用执行的时间
  在单处理器上，real 值和整个 CPU 用时之差，也就是 real - ( user + sys )是所有延迟程序执行的因素的总和。在 SMP 上，这个值近似为 real \* number_of_processors - ( user + sys )。这些因素包括：调入程序文本和数据的 IO 操作、获取程序实际使用内存的 IO 操作、由其它 程序消耗的 CPU 用时、由操作系统 消耗的 CPU 用时

2. 并行执行：{程序}&表示将程序放到后台并行执行，如果需要等待程序执行完毕再进行下面内容，需要加 wait
3. 密码生成工具：pwgen
4. shift 用法：位置参数可以用`shift`命令左移。比如`shift 3`表示原来的`$4`现在变成`$1`，原来的`$5`现在变成`$2`等等，原来的`$1`、`$2`、`$3`丢弃，`$0`不移动。不带参数的`shift`命令相当于`shift 1`；例子：累加所有位置参数。
5. expect 和 spawn

   - expect 实现自动和交互式任务进行通信
   - spawn 是进入 expect 环境后才可以执行的 expect 内部命令；主要的功能是给 ssh 运行进程加个壳，用来传递交互指令
   - 脚本开头 #!/usr/bin/expect
   - 执行方式 ./xxx.sh 或 /opt/shell/shell-100/012.sh 或 expect -f xxx.sh

6. 只显示一行： echo -ne "内容\r"
7. 判断用户的几种方式：
   - 1. echo $UID
   - 2. echo $USER
   - 3. id -u
   - 4. whoami
8. nohup 命令：用于在系统后台不挂断的运行命令，退出终端不会影响程序的运行，默认情况下，会输出一个名为 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到$Home/nohup.out 文件中
   - nohup /root/start.sh &

```shell
#!/usr/bin/expect

set username root             # 定义变量
set ip [lindex $argv 0]       # 使用位置参数 192.168.100.99
set pass [lindex $argv 1]
set timeout 10                # 设置超时时间30s
spawn ssh $username@$ip       # 交互程序开始后面跟命令或者指定程序
expect {                      # 捕获相关内容，获取匹配信息匹配成功则执行expect后面的程序动作
  "yes/no" { send "yes\r";exp_continue }      # exp_continue        在expect中多次匹配就需要用到
  "password" { send "$pass\r" }
}
expect "#"
send "rm -rf /tmp/*\r"
send "touch /tmp/file{1..3}\r"      # 发送指定的字符串信息
send "date\r"
send "exit\r"
expect eof                          # expect执行结束 退出


#!/bin/bash
ip=192.168.100.99
pass=fengpin@docker

/usr/bin/expect <<-END &>/dev/null
set time 30
spawn ssh docker@$ip

expect {
        "yes/no" { send "yes\r";exp_continue }
        "password:" { send "$pass\r" }
}

expect "#"
send "rm -rf /tmp/*\r"
send "touch /tmp/file{1..3}\r"
send "date\r"
send "exit\r"
expect eof
END         # END前后不能有空格！！！
```

7. ssh-keygen -t rsa -C "1456131152@qq.com" -f ~/.ssh/id_rsa 生成密钥，用于免密登录， -f 指定文件名 -t 指定创建密钥类型（rsa、rsa1、dsa） -C 提供注释
   - 复制公钥到其他主机： ssh-copy-id -i /home/danbo/.ssh/id_rsa.pub root@192.168.100.99
8. tr 从标准输入中通过替换，tr "-" " " 两个参数
9. cat <<-EOF 多行输出 EOF
10. trap

## 12. shell 100+ 案例

1. 打印 hello world！
2. 让用户自己输入字符串，如果用户输入的是 hello，请打印 world，否则打印“请输入 hello” => if [ -n "$str" -a "$str" = "hello" ]
3. 判断当前主机是否和远程主机是否 ping 通，如果用户输入的 ip 为空，请重新输入，输入超过五次，结束脚本。
4. 计算 1-100 奇数和（2500）、偶数和（2550）
5. 判断所输整数是否为质数
6. 通过位置变量创建 Linux 系统账户，密码设置为默认的 Changeme123，如果用户存在，提示”用户已存在，未做任何操作（密码未做初始化）。“
7. 批量加 5 个新用户，stu1~stu5 命名，并统一加一个新组，组名为 class(-G)，统一改密码为 Changeme123，要求这几个用户的家目录都在/rhome(-c)
8. 局域网内检查主机网络通讯：写一个脚本，局域网内，把能 ping 通的 IP 和不能 ping 通的 IP 分类，并保存到两个文本文件里
9.

- 9.1 判断/tmp/run 目录是否存在，如果不存在就建立，如果存在就删除目录里所有文件
- 9.2 交互模式要求输入一个 ip，然后脚本判断这个 IP 对应的主机是否 能 ping 通，输出结果类似于： Server 10.1.1.20 is Down! 最后要求把结果邮件到本地管理员 root@localhost
- 9.3 输入一个路径，判断路径是否存在，而且输出是文件还是目录，如果是链接文件，还得输出是 有效的连接还是无效的连接

10. 产生一个 phonenum.txt 文件，随机产生以 139 开头的手机号 1000 个，每个一行（不能重复）；随机抽出 5 位幸运观众。只显示头 3 个数和尾号的 4 个数，中间的都用\*代替
11. 打印三角形（正三角、直角等）、九九乘法表
12. 使用文件 ip_info.txt 远程连接服务器，从并输出时间 data 和文件列表 ls -lh，在 home 目录的 dangbo 文件夹创建 file1、2、3 三个文件
13. 输入一个等级（A-E），查看每个等级的成绩；如：输入 A，则显示“90 分~100 分”，依次类推
14. 将所有用户名分类，分为管理员用户，系统用户，普通用户。uid 判断：管理员 0、系统用户 0< xx >1000 =65534 、普通用户 1000<= xx !=65534
15. 收集用户输入的基本信息(姓名，性别，年龄)，如不输入一直提示输入
16. 把一个目录内的所有空文件都找出来，最后输出文件的个数
17. 倒计时：显示距离春节（2022-02-15 00:00:00）的时间
18. 通过位置变量创建系统账户以及密码
19. 备份日志：每天 10 点定时备份，将文件打成 xxx.tar.gz，文件名包含日期标签
20. 安装 jdk，并配置环境变量，最后检查是否安装成功
21. 监控内存和磁盘容量，小于给定值时报警 (内存使用 free 命令，磁盘使用 df 命令) echo "Server $ip is Down!" | mail -s "【alarm】" root@localhost
22. 猜数字游戏： 脚本生成一个 100 以内的随机数,提示用户猜数字,最后输出用户猜了多少次
23. 检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员
24. 编写脚本：提示用户输入用户名和密码,脚本自动创建相应的账户及配置密码。如果用户不输入账户名，则提示必须输入账户名并退出脚本;如果用户不输入密码，则统一使用默认的 123456 作为默认密码
25. 输入三个数并进行升序排序
26. 石头、剪刀、布游戏(计算机随机生成 1-3)
27. 编写脚本测试 192.168.100.0/24 整个网段中哪些主机处于开机状态,哪些主机处于关机状态(for 或 while、多进程三种实现方式)
28. 编写脚本，显示进度条(printf 格式化输出)
29. 编写脚本，显示进度条，动态时针加载；定义一个显示进度的函数；屏幕快速显示| / ‐ \
30. 使用 user.txt 文件中的人员名单,在计算机中自动创建对应的账户并配置初始密码本脚本执行,需要提前准备一个 user.txt 文件,该文件中包含有若干用户名信息
31. 编写批量修改扩展名脚本
32. 使用死循环实时显示 eth0 网卡发送的数据包流量(ifconfig eth0 | grep "RX pack" | awk '{print $5}')
33. 使用 expect 工具自动交互密码远程其他主机安装 httpd 软件
34. 点名器脚本：需要提前准备一个 user.txt 文件，该文件中需要包含所有姓名的信息，一行一个姓名，脚本每次随机显示一个姓名
35. 打印各种格式的时间
36. 检查特定的软件包是否已经安装
37. 打印国际象棋棋盘
38. 根据计算机当前时间，返回问候语，将该脚本设置为登录启动执行
39. 打印斐波那契数列，该数列的特点是后一个数字,永远都是前 2 个数字之和
40. 统计/etc/passwd 中 root 出现的次数
41. 找出/etc/passwd 中能登录的用户,并将对应在/etc/shadow 中第二列密码提出处理
42. 统计当前 Linux 系统中可以登录计算机的账户有多少个，统计当前登录系统的账户名
43. 统计/var/log 有多少个文件,并显示这些文件名
44. 使用 uuid（16 进制密码）随机生成密码 uuidgen
