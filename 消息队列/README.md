# Message Queue

MQ (message Queue) 消息队列，是将消息 message 存放到队列中（队列：先进先出 FIFO 的数据结构 ），它是一种跨进程的通信机制，用于上下游的消息传递，从而达到上下游解耦，消息发送上游只需要依赖 MQ，不需要依赖其他下游服务。

在系统架构设计中，经常会使用 MQ，常见的使用场景有异步处理、应用解耦、流量削峰、消息通讯、日志处理（Kafka）等。

- **应用解耦**：多个系统间的通信；
- **流量削峰**：每秒中由上万个请求写入 MQ 中，然后消费者慢慢去消费，不会使系统因为并发请求数量大，导致崩溃；
- **异步处理**
- **消息通讯**
- **日志处理**：使用 Kafka，解决大量日志传输的问题（ELK stack）。

同时，使用消息队列，也有缺点，比如增加了复杂度，存在一致性问题等。

- **增加了复杂度、降低了可用性**：本来系统之间可以直接通过调用接口就可以，但是引入 mq 会导致系统复杂性大大增加，并且如果 mq 挂掉，则系统间的通信中断，会导致整个系统全部挂掉；
- **存在一致性问题**：比如 A 系统处理完了发送消息给 mq 后直接返回成功，用户会认为这个请求成功，但是其他系统消费消息时，系统出现问题，导致数据丢失，最后就会发生数据不一致等问题。

#### 1. JMS 消息服务

JMS（Java Message Service），JMS API 是一个消息服务的标准/规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。

JMS 提供了两种消息模：

1. 点对点模型（Point-to-Point Messaging Domain）

消息生产者发送到 queue 中，然后消息消费者从 queue 中取出并消费信息，一条消息被消费以后，queue 中就没有了，不存在重复消费的问题

2. 发布/订阅模型（Publish/Subscribe Messaging Domain）

消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有的订阅者消费（类似于关注了微信公众号的人都能收到推送的文章）。

#### 2. AMQP

AMQP（advanced message queuing protocol），是一种网络协议，它支持符合要求的客户端应用和消息中间件代理之间进行通信，这个过程中的发布者，消费者，消息代理 可以存在于不同的设备上。

在 2003 年时被提出，最早用于解决金融领域不同平台之间的消息传递交互问题。

消息代理（message brokers）从发布者（publishers）亦称生产者（producers）那儿接收消息，并根据既定的路由规则把接收到的消息发送给处理消息的消费者（consumers）。

**模型简介**

AMQP 0-9-1 的工作过程：消息（message）被发布者（publisher）发送给交换机（exchange），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。

发布者（publisher）发布消息时可以给消息指定各种消息属性（message meta-data）。有些属性有可能会被消息代理（brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。

从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP 模块包含了一个消息确认（message acknowledgements）的概念：当一个消息从队列中投递给消费者后（consumer），消费者会通知一下消息代理（broker），这个可以是自动的也可以由处理消息的应用的开发者执行。当“消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执（acknowledgement）。

在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。

队列，交换机和绑定统称为 AMQP 实体（AMQP entities）。

在 AMQP 中，消息路由和 JMS 存在一些差别，在 AMQP 中增加了 Exchange 和 binding 的角色。producer 将消息发送给 Exchange，binding 决定 Exchange 的消息应该发送到那个 queue，而 consumer 直接从 queue 中消费消息。

**交换机类型**

交换机是用来发送消息的 AMQP 实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和被称作绑定（bindings）的规则所决定的。AMQP 0-9-1 的代理提供了四种交换机

| Name（交换机类型）            | Default pre-declared names（预声明的默认名称） |
| ----------------------------- | ---------------------------------------------- |
| Direct exchange（直连交换机） | (Empty string) and amq.direct                  |
| Fanout exchange（扇型交换机） | amq.fanout                                     |
| Topic exchange（主题交换机）  | amq.topic                                      |
| Headers exchange（头交换机）  | amq.match (and amq.headers in RabbitMQ)        |

除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：

- Name
- Durability （消息代理重启后，交换机是否还存在）
- Auto-delete （当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它）
- Arguments（依赖代理本身）

交换机可以有两个状态：持久（durable）、暂存（transient）。持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。然而并不是所有的应用场景都需要持久化的交换机。

1. **默认交换机**

默认交换机（default exchange）实际上是一个由消息代理预先声明好的没有名字（名字为空字符串）的直连交换机（direct exchange）。它有一个特殊的属性使得它对于简单应用特别有用处：那就是每个新建队列（queue）都会自动绑定到默认交换机上，绑定的路由键（routing key）名称与队列名称相同。

举个栗子：当你声明了一个名为"search-indexing-online"的队列，AMQP 代理会自动将其绑定到默认交换机上，绑定（binding）的路由键名称也是为"search-indexing-online"。因此，当携带着名为"search-indexing-online"的路由键的消息被发送到默认交换机的时候，此消息会被默认交换机路由至名为"search-indexing-online"的队列中。换句话说，默认交换机看起来貌似能够直接将消息投递给队列，尽管技术上并没有做相关的操作。

2. **直连交换机**

直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。直连交换机用来处理消息的单播路由（unicast routing）（尽管它也可以处理多播路由）。下边介绍它是如何工作的：

- 将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）
- 当一个携带着路由键为 R 的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为 R 的队列。

直连交换机经常用来循环分发任务给多个工作者（workers）。当这样做的时候，我们需要明白一点，在 AMQP 0-9-1 中，消息的负载均衡是发生在消费者（consumer）之间的，而不是队列（queue）之间。

3. **扇形交换机**

扇型交换机（fanout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果 N 个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的 N 个队列。扇型用来交换机处理消息的广播路由（broadcast routing）。

因为扇型交换机投递消息的拷贝到所有绑定到它的队列，所以他的应用案例都极其相似：

- 大规模多用户在线（MMO）游戏可以使用它来处理排行榜更新等全局事件
- 体育新闻网站可以用它来近乎实时地将比分更新分发给移动客户端
- 分发系统使用它来广播各种状态和配置更新
- 在群聊的时候，它被用来分发消息给参与群聊的用户。（AMQP 没有内置 presence 的概念，因此 XMPP 可能会是个更好的选择）

4. **主题交换机**

主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。

主题交换机拥有非常广泛的用户案例。无论何时，当一个问题涉及到那些想要有针对性的选择需要接收消息的 多消费者/多应用（multiple consumers/applications） 的时候，主题交换机都可以被列入考虑范围。

使用案例：

- 分发有关于特定地理位置的数据，例如销售点
- 由多个工作者（workers）完成的后台任务，每个工作者负责处理某些特定的任务
- 股票价格更新（以及其他类型的金融数据更新）
- 涉及到分类或者标签的新闻更新（例如，针对特定的运动项目或者队伍）
- 云端的不同种类服务的协调
- 分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统。

5. **头交换机**

有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。

我们可以绑定一个队列到头交换机上，并给他们之间的绑定使用多个用于匹配的头（header）。这个案例中，消息代理得从应用开发者那儿取到更多一段信息，换句话说，它需要考虑某条消息（message）是需要部分匹配还是全部匹配。上边说的“更多一段消息”就是"x-match"参数。

- 当"x-match"设置为“any”时，消息头的任意一个值被匹配就可以满足条件，
- 当"x-match"设置为“all”的时候，就需要消息头的所有值都匹配成功。

头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作，不同之处在于头交换机的路由规则是建立在头属性值之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们甚至可以是整数或者哈希值（字典）等。

**队列**

AMQP 中的队列（queue）跟其他消息队列或任务队列中的队列是很相似的：它们存储着即将被应用消费掉的消息。队列跟交换机共享某些属性，但是队列也有一些另外的属性。

- Name
- Durable（消息代理重启后，队列依旧存在）
- Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）
- Auto-delete（当最后一个消费者退订后即被删除）
- Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）

#### 3. MQ 的选择

1. Kafka

Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了

2. RocketMQ

天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。

3. RabbitMQ

RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。结合 erlang 语言本身的并发优势，性能好，时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。

4. ActiveMQ

Java 世界的中坚力量，是基于 JMS 协议；基本弃用。

| 特性                     | ActiveMQ                                                                                                                                                                                 | RabbitMQ                                                                                                                                                                           | RocketMQ                                                                                                                                                                                                                            | Kafka                                                                                                                                                                                                                                                         |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 单机吞吐量               | 万级                                                                                                                                                                                     | 万级                                                                                                                                                                               | 10 万级                                                                                                                                                                                                                             | 10 万级景                                                                                                                                                                                                                                                     |
| 时效性                   | ms 级                                                                                                                                                                                    | 微秒级，延迟最低                                                                                                                                                                   | ms 级                                                                                                                                                                                                                               | 延迟在 ms 级内                                                                                                                                                                                                                                                |
| 可用性                   | 高，基于主从架构实现的高可用性                                                                                                                                                           | 高，基于主从架构实现的高可用性                                                                                                                                                     | 非常高，分布式架构                                                                                                                                                                                                                  | 非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用                                                                                                                                                                        |
| 消息可靠性               | 有较低的概率丢失数据                                                                                                                                                                     | 基本不丢                                                                                                                                                                           | 经过参数优化配置，可以做到 0 丢失                                                                                                                                                                                                   | 经过参数优化配置，可以做到 0 丢失                                                                                                                                                                                                                             |
| topic 数量对吞吐量的影响 |                                                                                                                                                                                          |                                                                                                                                                                                    | 支持 10 亿级别的消息堆积，不会因为堆积导致性能下降，如果达到几百/几千的级别，吞吐量会有较小幅度的下降，这事 RocketMQ 的一大优势，在同等机器侠，可以支持大量的 topic                                                                 | topic 从几十到几百个的时候，吞吐量会大幅度下降，在同等机下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源                                                                                                               |
| 功能支持                 | MQ 领域的功能极其完备                                                                                                                                                                    | 基于 erlang 开发，并发能力很强，性能极其好，延时很低                                                                                                                               | MQ 功能较为完善，还是分布式的，扩展性好                                                                                                                                                                                             | 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算、日志采集被大规模使用                                                                                                                                                                            |
| 优劣势总结               | 偶尔会有较低概率丢失消息，现在社区活跃度低，国内应用都越来越少；官方社区现在对 ActiveMQ 5.x 维护越来越少，几个月才发布一个版本，主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 | 性能极其好，延时很低；吞吐量到万级，MQ 功能比较完备而且开源提供的管理界面非常棒，用起来很好用，社区活跃度高，更新频率相当高。RabbitMQ 吞吐量会低一些，这是因为他做的实现机制比较重 | 出自阿里巴巴的开源产品，用 java 语言实现，接口简单易用，被阿里广泛应用在订单，交易，充值，流计算，消息推送，日志流处理等场景，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，还可以支撑大规模的 topic 数量。 | kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量，目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳 |
