# 架构

## 1. 架构图

水平层面上的业务模块加上垂直方向上的技术模块依赖形成的逻辑结构图。

框框图 ，以前是4+1图

传统架构图（4+1图）：

- 物理视图：和部署相关的架构决策（一般不画）
- 逻辑视图：设计满足功能需求的架构（逻辑结构图）
- 开发视图：设计满足开发期质量属性的架构（UML图）
- 处理视图：设计满足运行期质量属性的架构（UML图）
- `场景视图: 需求分析技术，通常采用UML的用例图进行设计`

### 6.1 怎么画

1. 搞清楚要画的架构图的类型
2. 确认架构图的关键要素（比如产品、技术、服务）
3. 梳理关键要素之间的关联：包含、支撑、同级并列等
4. 输出关联关系清晰的架构图

### 6.2 画的好坏

1. 布局：图形的上下左右前后6个方向的位置关系

2. 颜色：视觉中心在哪儿，哪些元素被忽略

3. 逻辑：组件之间的依赖，业务实现的可行性

## 1. 画图


> E-R 图的工具：
>  
> 1. 微软 visio
> 2. processon（网页版本，免费版可以使用9张图。）
> 3. 亿图
> 4. xmind 思维导图
> 5. draw.io

### 5.1 流程图

常见的流程图形状及其使用说明：

- 起止框：椭圆形状，表示流程的开始和结束。流程图只能有一个开始节点和一个结束节点。
- 处理框：矩形方框形状。
- 判断框：菱形形状，表示条件判断，根据条件的真假决定流程的走向。
- 输入/输出框：平行四边形形状，表示与外部环境进行输入和输出。
- 连接线：表示流程的流转方向。
- 文档框：文档，增加注释或说明信息。

### 5.2 ER图

ER图也称实体关系图（Entity Relationship Diagram），提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。由三个要素组成

- 实体：使用矩形框表示。通常是现实世界的业务对象，当然使用一些逻辑对象也可以。
- 属性：使用椭圆形表示。即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说，可以理解为字段。
- 关系：实体之间的关系

**实际使用时，不应该拘泥于形式。**

虽然 ER 图是一种规范，但是有时候为了更清晰地表明业务对象属性或关系，可以做一些变通。

实际梳理业务对象关系的时候，我们可以先列举出某个模块涉及到的业务对象，然后再注明业务对象之间的联系。至于属性，可以根据实际情况决定要不要标明。因为，属性标记太多的话会占据 ER 图的大部分区域，反而导致实体关系不容易察觉。



### 5.2 UML

UML（Unified Modeling Language）统一建模语言，是一种用于软件系统建模的标准化语言，它提供了一组图形化符号和规范，用于描述和可视化系统的结构、行为和交互。通过使用UML，开发人员可以更好地理解和沟通系统设计和功能。

分类：

静态结构图：类图、对象图、包图、组件图、部署图

动态行为图：交互图（时序图与协作图）、状态图、活动图 

UML提供了多种图表类型，包括类图、对象图、用例图、序列图、状态图、活动图等，每种图表都有其特定的用途和表示方式。开发人员可以根据需要选择合适的图表，来表示系统中不同的方面和关系。

UML的使用可以帮助开发团队在不同阶段进行系统设计和分析，从而确保开发过程中的一致性和有效性。它被广泛应用于软件开发领域，并且还可以用于其他领域的系统建模，如业务流程建模、数据库设计等。

1. 用例图

2. 类图

3. 状态图

4. 活动图

5. 时序图

6. 协作图

7. 系统部署图



   
![Alt text](image.png)

## 7. 软件架构

架构模式虽多，但常用的也就那么几种。



### 7.1 分层架构

分层架构，英文名layered architecture，是最常见的软件架构模式。它将软件分成若干个水平层，每一层都有清晰的角色和分工，层与层之间通过接口通信。

优点：

- 可扩展性
- 可维护性
- 可测试性，每一层都可以独立测试，其他层的接口通过模拟解决

缺点：

- 增加需求必须一次扩展每一层，由于每一层内部都是耦合的，扩展会很困难



水平层面上的业务模块加上垂直方向上的技术模块依赖形成的逻辑结构图

## 8. openfeign使用方式

实际项目种，openfeign使用各式各样。

### 8.1 声明式

这种方式最简单。但是声明式会多写一次提供者接口的定义，也就是有重复的代码。

1. 消费者增加一个接口，使用@FeignClient(name="xxx")注解标注。

```java
// 会扫描指定包下，标记FeignClient注解的接口，然后根据服务名，从注册中心找到对应的IP地址
@FeignClient(name = "provider")
public interface ProviderClient {
    // 这里跟提供者接口的URL一致
    @RequestMapping("/provider/list")
    String list();
}
```

2. 消费者在使用时，直接通过spring注入的方式注入即可。（也可以通过Spring Cloud Feign提供的工厂类获取实例）

```java
@RestController
public class ConsumerController {
    //引入Feign客户端
    @Resource
    private ProviderClient providerClient;

    @RequestMapping("/consumer/callProvider")
    public String callProvider() {
        //使用Feign客户端调用其他服务的接口
        return providerClient.list();
    }
}
```

2. 提供者编写对应的controller接口。只要保证跟消费者工程中ProviderClient接口里边方法 URL一致！

### 8.2 继承式

1. 创建一个普通的maven项目api工程，把接口定义在api中。(该模块就叫做xxx-api)

```java
public interface ProviderApi {
    @RequestMapper("/provider/list")
    String list();
}
```

2. 提供者工程引入api模块依赖，实现providerApi接口，并使用@RestController标注实现类。

```
@RestController    // 提供 RESTful API 接口，给 Feign 调用
public class ProviderApiImpl implements ProviderApi {
    public String list() {
        List<String> list = new ArrayList<>();
        return list.toString();
    }
}
```

3. 消费者配置，无需定义接口，只需要引入xxx-api模块依赖。
   - 继承ProviderApi，然后在子接口上标注@FiegnCilent(name="xxx")即可。
   - 直接在api模块中的接口上标注@FiegnCilent(name="xxx")，不需要写子接口。

4. 消费者使用。直接通过spring注入的方式注入即可。



























