# 概念

OAuth2.0（Open Authorization）开放授权。

## OAuth2.0 背景

**OAuth 1.0**

在 OAuth 1.0 的时候，它有个 “很大的愿望” 就是想用一套授权机制来应对现实中的所有场景，比如 Web 应用场景、移动 App 应用场景、官方应用场景等等，但是这些场景并不是完全相同的。比如官方应用场景，你说还需要让用户来授权吗？如果需要，始终使用一套授权机制给用户带来的体验，是好还是坏呢？

到了 OAuth 2.0 的时候，就解决了 OAuth 1.0 面临的这种“尴尬”。OAuth 2.0 不再局限于一种授权机制，它扩充了授权许可机制类型，有了授权码许可机制、客户端凭据机制、资源拥有者凭据机制和隐式许可机制。这样的 OAuth 机制就能够很灵活地适应现实中的各种场景，比如移动应用的场景、官方应用的场景，等等。

此外，OAuth 1.0 的弊端还包括安全上的固化攻击等问题，因此 OAuth 1.0 现在已经是废弃状态了。对于我们来讲，直接使用 OAuth 2.0 就可以了。

## 四种角色

1. 资源拥有者
2. 客户端
3. 授权服务
4. 受保护资源

[OAuth2.0 授权许可类型]()

## 四种类型

1. 授权码许可类型
2. 资源拥有者凭据许可
3. 隐式许可
4. 客户端凭据许可

| 类型                   | 英文                                | grant_type         | 特点                 | 适用场景                                                                   |
| ---------------------- | ----------------------------------- | ------------------ | -------------------- | -------------------------------------------------------------------------- |
| 客户端凭据许可类型     | Client Credentials                  | client_credentials | 无需用户参与         | 常用于应用之间的后台通信，如微服务架构下的服务调用，或系统间集成等场景景。 |
| 资源拥有者凭据许可类型 | Resource Owner Password Credentials | password           | 要求客户端可完全信任 | 适用于内部使用的应用程序，或用户和应用之间有很强信任关系的场景             |
| 授权码许可类型         | Authorization Code                  | authorization_code | 最安全、最常用的模式 | 常用于 Web 应用，如第三方登录功能，像网易云音乐使用 QQ 登录等场景。        |
| 隐式许可类型           | Implicit Grant                      | 无明确固定值标识   | 安全性较差           | 用于前端 JavaScript 应用、移动应用等，且没有服务器端来安全存储凭证的场景。 |

### 资源拥有者凭据许可

软件是官方出品的，又要使用 OAuth2.0 来保护 Web API，就采用资源拥有者凭据许可类型。

### 客户端凭据许可

如果没有明确的资源拥有者，也可以形象地理解为 “资源拥有者被塞进了第三方软件中” 或者 “第三方软件就是资源拥有者”。这种场景下的授权，第三方软件可以直接使用注册时的 app_id 和 app_secret 来换回访问令牌 token 的值。

虽然这种模式比较简便，但是已经失去了用户验证的意义，压根就不是给用户校验准备的，而是更适用于服务内部调用的场景。

比如获取京东 LOGO 的图片地址；
比如其他类型的第三方软件来访问平台提供的省份信息，省份信息也不属于任何一个第三方用户。

### 隐式许可

如果你的软件就是直接嵌入到了浏览器中运行，而且还没有服务端的参与，并且还想使用 OAuth 2.0 流程的话，那么便可以直接使用隐式许可类型了。

refresh_token 存在的意义是什么？access_token 过期了，为什么要用 refresh_token 去获取 access_token，好像重新获取 access_token 也行

为了不烦最终用户频繁的点击【授权】按钮动作，才有了这样的机制；
在 隐式许可和客户端凭据许可，这两种许可类型下，不需要 refresh_token，他们可以直接根据 app_id 和 secret 来换取访问令牌，因为，1-隐式许可对任何内容都是“透明的”，也没有必要存在 refresh_token，2-客户端凭据许可，既然是叫做“客户端凭据”了，在获取那些没有跟用户强关联的信息的时候，比如 国家省市信息类似的信息，其实没有用户参与的必要性，当然可以随时获取令牌。

### 授权服务流程

1. 客户端需要在授权服务注册，注册完后，授权服务就会给客户端 app_id 和 app_secret 等信息，以方便后边授权时的各种身份校验。
2. 注册的时候，客户端也会请求受保护资源的可访问范围。
3.

## OIDC

OIDC (OpenID Connect) 是一种用户身份认证得开放标准。

OAuth 2.0 是一种授权协议，而不是身份认证协议。OIDC 才是身份认证协议，而且是基于 OAuth 2.0 来执行用户身份认证得互通协议。更概括的说，OIDC 就是直接基于 OAuth 2.0 构建的身份认证框架协议。换种表示方式， OIDC = 授权协议 + 身份认证，是 OAuth 2.0 的超集。

OIDC 的三个主要角色：

1. EU (End User) 代表最终用户
2. RP (Relying Party) 代表认证服务的依赖方，就是第三方软件。
3. OP (OpenID Provider) 代表提供身份认证服务方。

基于授权码流程的 OIDC 协议流程，跟 OAuth 2.0 中的授权码许可的流程几乎完全一致，唯一的区别就是多返回了一个 ID_TOKEN，这个 ID 令牌是

## 示例

### 与 security 区别

```xml
<dependency>
	<groupId>org.springframework.security.oauth</groupId>
	<artifactId>spring-security-oauth2</artifactId>
	<version>2.5.2.RELEASE</version>
</dependency>
```

org.springframework.security.oauth 是 Spring Security OAuth 模块的 Maven 依赖项，用于实现 OAuth 2.0 认证和授权功能。它提供了一组用于保护和管理 OAuth 2.0 资源服务器的类和工具。

而 spring-security 是 Spring Security 框架的核心模块，用于提供身份验证（Authentication）和授权（Authorization）功能。它可以用于保护 Web 应用程序的安全性，包括
用户认证、访问控制和安全事件管理等。

简而言之，spring-security-oauth2 模块是 Spring Security 框架中专门用于处理 OAuth 2.0 的扩展，它提供了在实现 OAuth 2.0 认证和授权时所需的类和方法。

如果你的项目需要实现 OAuth 2.0 认证和授权功能，可以使用 spring-security-oauth2 依赖。而如果你只需要基本的身份验证和授权功能，可以使用 spring-security 框架的其他模块。
